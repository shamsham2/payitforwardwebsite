(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.VueInheritSlots = {})));
}(this, (function (exports) { 'use strict';

  // Created / adapted custom implementations of methods available from lodash and deepmerge as they were adding nearly
  //  180kb to the generated lib files

  // Solution found here: https://stackoverflow.com/a/37616104/400699
  function filterObject(object, predicate) {
    if (typeof object === 'undefined') {
      return {}
    } else {
      return Object.keys(object)
        .filter(function (key) { return predicate(key, object[key]); })
        .reduce(function (result, key) { return ((result[key] = object[key]), result); }, {})
    }
  }

  function omit(object, keys) {
    return filterObject(object, function (key) { return keys.indexOf(key) === -1; })
  }

  // Adapted from https://youmightnotneed.com/lodash/
  function flatten(array) {
    return array.reduce(function (a, b) { return a.concat(b); }, [])
  }

  // TODO: implement alternate approach where a default scope is evaluated with props included the merged slots and scopedSlots

  var InheritSlots = {
    props: {
      inheritDefaultSlot: {
        type: Boolean,
        default: false
      }
    },
    functional: true,
    render: function render(h, context) {
      // pull in the context.slots() in case the user wants to merge these with the parent slots
      var allSlots = context.slots();

      // if scopedSlots were passed in, parent scopedSlots will be merged into this hash
      var scopedSlots = context.data.scopedSlots;

      var ref = context.props;
      var inheritDefaultSlot = ref.inheritDefaultSlot;
      var parent = context.parent;

      var parentSlots = inheritDefaultSlot
        ? parent.$slots
        : omit(parent.$slots, ['default']);

      Object.entries(parentSlots).forEach(function (ref) {
        var slotName = ref[0];
        var slots = ref[1];

        allSlots[slotName] = slots.concat(allSlots[slotName] || []);
      });

      if (scopedSlots) {
        var parentScopedSlots = parent.$scopedSlots || {};
        if (!inheritDefaultSlot) {
          parentScopedSlots = omit(parentScopedSlots, ['default']);
        }
        Object.entries(parentScopedSlots).forEach(function (ref) {
          var key = ref[0];
          var value = ref[1];

          scopedSlots[key] = value;
        });
      }

      // This makes the slots child slots of the component that is inheriting slots
      var slotChildren = flatten(Object.values(allSlots));
      return slotChildren
    }
  };

  var VueInheritSlotsPlugin = {
    install: function install(Vue, options) {
      if ( options === void 0 ) options = {};

      Vue.component(options.alias || 'InheritSlots', InheritSlots);
    }
  };

  // Automatic installation if Vue has been added to the global scope.
  if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(VueInheritSlotsPlugin);
  }

  exports.default = VueInheritSlotsPlugin;
  exports.InheritSlots = InheritSlots;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
