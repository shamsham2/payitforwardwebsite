(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue-slot-hooks'), require('vue-inherit-slots')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue-slot-hooks', 'vue-inherit-slots'], factory) :
  (factory((global.VueTableFor = {}),global.VueSlotHooks,global.VueInheritSlots));
}(this, (function (exports,vueSlotHooks,vueInheritSlots) { 'use strict';

  // Created / adapted custom implementations of methods available from lodash and deepmerge as they were adding nearly
  //  180kb to the generated lib files
  // Other HelperUtils will be imported from the vue-slot-hooks plugin

  // Adapted from https://stackoverflow.com/a/41246860/400699
  function range(start, end) {
    return Array.apply(null, Array(end - start)).map(function (k, index) { return index + start; })
  }

  // Based partially on https://github.com/sindresorhus/titleize
  function startCase(string) {
    if (string) {
      return string
        .replace(/[_-]/g, ' ')
        .toLowerCase()
        .replace(/(?:^|\s|-)\S/g, function (x) { return x.toUpperCase(); })
    }
  }

  // Created / adapted custom implementations of methods available from lodash and deepmerge as they were adding nearly
  //  180kb to the generated lib files

  // Solution found here: https://stackoverflow.com/a/37616104/400699
  function filterObject(object, predicate) {
    if (typeof object === 'undefined') {
      return {}
    } else {
      return Object.keys(object)
        .filter(function (key) { return predicate(key, object[key]); })
        .reduce(function (result, key) { return ((result[key] = object[key]), result); }, {})
    }
  }

  function omit(object, keys) {
    return filterObject(object, function (key) { return keys.indexOf(key) === -1; })
  }

  function pick(object, keys) {
    return filterObject(object, function (key) { return keys.indexOf(key) !== -1; })
  }

  // import RenderWithSlotHooks from '../../../vue-slot-hooks/src/components/RenderWithSlotHooks'

  var TableHeaderColumn = {
    props: {
      columnDefinition: {
        type: Object,
        required: true
      },
      header: {
        type: Object,
        default: function default$1() {
          return {}
        }
      },
      recordVariable: {
        type: String,
        default: 'record'
      }
    },
    functional: true,
    render: function render(createElement, context) {
      var ref = context.props;
      var columnDefinition = ref.columnDefinition;

      var ref$1 = columnDefinition.data.attrs;
      var name = ref$1.name;
      var header = ref$1.header;
      var globalHeaderOptions = context.props.header;
      if (typeof globalHeaderOptions === 'function') {
        globalHeaderOptions = globalHeaderOptions(columnDefinition);
      }

      var headerAttrs = omit(globalHeaderOptions, ['content', 'formatter']);

      var headerColumnOptions = pick(globalHeaderOptions, [
        'content',
        'formatter'
      ]);

      if (typeof header !== 'undefined') {
        if (typeof header === 'object') {
          headerAttrs = Object.assign({}, headerAttrs,
            omit(header, ['content', 'formatter']));
          headerColumnOptions = Object.assign({}, headerColumnOptions,
            pick(header, ['content', 'formatter']));
        } else {
          headerColumnOptions.content = header;
        }
      }

      var content = headerColumnOptions.content;
      var formatter = headerColumnOptions.formatter;

      var slots = context.slots();
      if (slots.default) {
        content = slots.default;
      } else {
        if (typeof content === 'undefined') {
          content = startCase(name);
        }

        if (typeof content === 'boolean' && !content) {
          content = null;
        } else if (formatter) {
          content = formatter(content);
        }

        content = [content];
      }

      return createElement(
        vueSlotHooks.RenderWithSlotHooks,
        {
          props: {
            inheritSlots: true,
            slotName: (name + "_header"),
            tag: 'th',
            tagData: { attrs: headerAttrs },
            passSlotsToTag: false
          }
        },
        content
      )
    }
  };

  // import RenderWithSlotHooks from '../../../vue-slot-hooks/src/components/RenderWithSlotHooks'

  var TableHeader = {
    functional: true,
    props: Object.assign({}, pick(TableHeaderColumn.props, ['header', 'recordVariable'])),
    render: function render(h, context) {
      var obj;

      var columns;
      var scopedSlots = context.data.scopedSlots || {};
      var scopedSlot = scopedSlots.default;
      var ref = context.props;
      var recordVariable = ref.recordVariable;

      if (scopedSlot) {
        var proxyHash = new Proxy({}, { get: function () { return ''; } });
        columns = scopedSlot(( obj = {}, obj[recordVariable] = proxyHash, obj ));
      } else {
        columns = context.slots().default;
      }
      columns = columns.filter(function (column) { return column.tag === 'td'; });

      var header = h(
        vueSlotHooks.RenderWithSlotHooks,
        {
          props: {
            inheritSlots: true,
            slotName: 'header',
            tag: 'thead',
            passSlotsToTag: false
          }
        },
        h(
          vueSlotHooks.RenderWithSlotHooks,
          {
            props: {
              inheritSlots: true,
              slotName: 'header_row',
              tag: 'tr',
              passSlotsToTag: false
            }
          },
          columns.map(function (columnDefinition) { return h(TableHeaderColumn, {
              props: Object.assign({}, pick(context.props, Object.keys(TableHeaderColumn.props)),
                {columnDefinition: columnDefinition})
            }); }
          )
        )
      );

      return header
    }
  };

  var TableDataColumn = {
    props: {
      record: {
        default: function default$1() {
          return {}
        }
      },
      name: {
        type: String,
        required: true
      },
      field: {
        type: String,
        default: null
      },
      content: {},
      formatter: {
        type: Function
      },
      recordVariable: {
        type: String,
        default: 'record'
      }
    },
    functional: true,
    render: function render(createElement, context) {
      var ref = context.props;
      var record = ref.record;
      var content = ref.content;
      var formatter = ref.formatter;
      var name = ref.name;
      var field = ref.field;
      var scopedSlots = context.data.scopedSlots || {};

      var defaultSlot = context.slots().default;
      field = field || name;
      if (typeof content === 'undefined' && record.hasOwnProperty(field)) {
        content = record[field];
      }
      if (formatter && typeof content !== 'undefined') {
        content = formatter(content, Object.assign({}, context.data,
          {record: record}));
      }
      var children;
      if (scopedSlots.default) {
        children = scopedSlots.default({ record: record });
      } else if (defaultSlot) {
        children = defaultSlot;
      } else {
        children = [content];
      }

      return createElement(
        vueSlotHooks.RenderWithSlotHooks,
        {
          props: {
            inheritSlots: true,
            slotName: name,
            tag: 'td',
            tagData: omit(context.data, ['props']),
            passSlotsToTag: false
          }
        },
        children
      )
    }
  };

  var TableDataRow = {
    functional: true,
    props: Object.assign({}, {columns: {
        type: Array,
        required: true
      },
      dataRow: {
        default: function default$1() {
          return {}
        }
      }},
      pick(TableDataColumn.props, ['record', 'formatter', 'recordVariable'])),

    render: function render(h, context) {
      var ref = context.props;
      var columns = ref.columns;
      var dataRow = ref.dataRow;
      var record = ref.record;

      if (typeof dataRow === 'function') {
        dataRow = dataRow(record);
      } else {
        dataRow = Object.assign({}, dataRow);
      }
      if (!dataRow.key) { dataRow.key = "record-" + (record.id); }
      dataRow.props = {
        record: record
      };

      return h(
        vueSlotHooks.RenderWithSlotHooks,
        {
          props: {
            inheritSlots: true,
            slotName: 'data_row',
            tag: 'tr',
            tagData: dataRow,
            passSlotsToTag: false
          }
        },
        columns.map(function (column) {
          var dataColumnOptions = Object.assign({}, column.data,
            {attrs: omit(column.data.attrs, Object.keys(TableDataColumn.props).concat( Object.keys(TableHeaderColumn.props)
            )),
            props: Object.assign({}, pick(context.props, Object.keys(TableDataColumn.props)),
              pick(column.data.attrs, Object.keys(TableDataColumn.props)))});

          return h(TableDataColumn, dataColumnOptions, column.children)
        })
      )
    }
  };

  // import RenderWithSlotHooks from '../../../vue-slot-hooks/src/components/RenderWithSlotHooks'

  var TableBody = {
    props: Object.assign({}, {records: {
        type: Array,
        required: true
      },
      body: {
        type: Object,
        default: function default$1() {
          return {}
        }
      }},
      pick(TableDataRow.props, ['recordVariable', 'formatter', 'dataRow'])),
    functional: true,
    render: function render(h, context) {
      var scopedSlots = context.data.scopedSlots || {};
      var scopedSlot = scopedSlots.default;
      var defaultSlot = context.slots().default;
      var ref = context.props;
      var recordVariable = ref.recordVariable;
      var records = ref.records;
      var body = ref.body;

      return h(
        vueSlotHooks.RenderWithSlotHooks,
        {
          props: {
            inheritSlots: true,
            slotName: 'body',
            tag: 'tbody',
            tagData: body,
            passSlotsToTag: false
          }
        },
        records.map(function (record) {
          var obj;

          var columns;
          if (scopedSlot) {
            columns = scopedSlot(( obj = {}, obj[recordVariable] = record, obj ));
          } else {
            columns = defaultSlot;
          }

          columns = columns.filter(function (column) { return column.tag === 'td'; });

          return h(TableDataRow, {
            props: Object.assign({}, {columns: columns,
              record: record},
              pick(context.props, Object.keys(TableDataRow.props)))
          })
        })
      )
    }
  };

  //

  var script = {
    props: {
      paginationInnerWindow: {
        type: Number,
        default: 4
      },
      paginationOuterWindow: {
        type: Number,
        default: 1
      },
      currentPage: {
        type: Number,
        required: true
      },
      totalPages: {
        type: Number,
        required: true
      }
    },
    methods: {
      setPage: function setPage(i, event) {
        if ( event === void 0 ) event = null;

        if (i > 0 && i <= this.totalPages) {
          this.$emit('update:currentPage', i);
        }
        if (event) {
          event.target.blur();
        }
      },
      // Adapted with love from will_paginate gem:
      //  https://github.com/mislav/will_paginate/blob/master/lib/will_paginate/view_helpers/link_renderer_base.rb#L28
      windowedPageNumbers: function windowedPageNumbers() {
        if (this.totalPages === 0) {
          return []
        }

        var windowFrom = this.currentPage - this.paginationInnerWindow;
        var windowTo = this.currentPage + this.paginationInnerWindow;
        var middle, left, right;

        if (windowTo > this.totalPages) {
          windowFrom -= windowTo - this.totalPages;
          windowTo = this.totalPages;
        }

        if (windowFrom < 1) {
          windowTo += 1 - windowFrom;
          windowFrom = 1;

          if (windowTo > this.totalPages) { windowTo = this.totalPages; }
        }

        // these are always visible
        middle = range(windowFrom, windowTo + 1);

        // left window
        if (this.paginationOuterWindow + 3 < middle[0]) {
          // there's a pagination gap
          left = range(1, this.paginationOuterWindow + 2);
          left.push('gap1');
        } else {
          // runs into visible pages
          left = range(1, middle[0]);
        }
        // right window
        if (
          this.totalPages - this.paginationOuterWindow - 2 >
          middle[middle.length - 1]
        ) {
          // again, gap
          right = range(
            this.totalPages - this.paginationOuterWindow,
            this.totalPages + 1
          );
          right.unshift('gap2');
        } else {
          // runs into visible pages
          right = range(middle[middle.length - 1] + 1, this.totalPages + 1);
        }

        return left.concat(middle).concat(right)
      }
    }
  };

  /* script */
              var __vue_script__ = script;
              
  /* template */
  var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{attrs:{"aria-label":"Page navigation","align":"right"}},[_c('ul',{staticClass:"pagination"},[_c('li',{class:{ disabled: _vm.currentPage === 1 }},[_c('a',{attrs:{"href":"#","aria-label":"Previous"},on:{"click":function($event){$event.preventDefault();_vm.setPage(_vm.currentPage - 1, $event);}}},[_c('span',{attrs:{"aria-hidden":"true"}},[_vm._v("«")])])]),_vm._v(" "),_vm._l((_vm.windowedPageNumbers()),function(i){return _c('li',{key:("page-" + i),class:{ active: i === _vm.currentPage }},[(i === 'gap1' || i === 'gap2')?_c('span',{staticClass:"gap"},[_vm._v("…")]):_c('a',{attrs:{"href":"#"},on:{"click":function($event){$event.preventDefault();_vm.setPage(i, $event);}}},[_vm._v(_vm._s(i))])])}),_vm._v(" "),_c('li',{class:{ disabled: _vm.currentPage === _vm.totalPages }},[_c('a',{attrs:{"href":"#","aria-label":"Next"},on:{"click":function($event){$event.preventDefault();_vm.setPage(_vm.currentPage + 1, $event);}}},[_c('span',{attrs:{"aria-hidden":"true"}},[_vm._v("»")])])])],2)])};
  var __vue_staticRenderFns__ = [];

    /* style */
    var __vue_inject_styles__ = undefined;
    /* scoped */
    var __vue_scope_id__ = undefined;
    /* module identifier */
    var __vue_module_identifier__ = undefined;
    /* functional template */
    var __vue_is_functional_template__ = false;
    /* component normalizer */
    function __vue_normalize__(
      template, style, script$$1,
      scope, functional, moduleIdentifier,
      createInjector, createInjectorSSR
    ) {
      var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};

      // For security concerns, we use only base name in production mode.
      component.__file = "PaginationLinks.vue";

      if (!component.render) {
        component.render = template.render;
        component.staticRenderFns = template.staticRenderFns;
        component._compiled = true;

        if (functional) { component.functional = true; }
      }

      component._scopeId = scope;

      return component
    }
    /* style inject */
    
    /* style inject SSR */
    

    
    var PaginationLinks = __vue_normalize__(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      undefined,
      undefined
    );

  // Created / adapted custom implementations of methods available from lodash and deepmerge as they were adding nearly
  //  180kb to the generated lib files

  // Solution found here: https://stackoverflow.com/a/37616104/400699
  function filterObject$1(object, predicate) {
    if (typeof object === 'undefined') {
      return {}
    } else {
      return Object.keys(object)
        .filter(function (key) { return predicate(key, object[key]); })
        .reduce(function (result, key) { return ((result[key] = object[key]), result); }, {})
    }
  }

  function pick$1(object, keys) {
    return filterObject$1(object, function (key) { return keys.indexOf(key) !== -1; })
  }

  var TableFooter = {
    props: Object.assign({}, {recordVariable: {
        type: String,
        default: 'record'
      },
      paginationLinksInFooter: {
        type: Boolean,
        default: true
      },
      paginated: {
        type: Boolean,
        default: false
      }},
      PaginationLinks.props),
    functional: true,
    render: function render(h, context) {
      var obj;

      var scopedSlots = context.data.scopedSlots || {};
      var listeners = context.listeners || {};
      var scopedSlot = scopedSlots.default;
      var defaultSlot = context.slots().default;
      var ref = context.props;
      var recordVariable = ref.recordVariable;
      var paginated = ref.paginated;
      var totalPages = ref.totalPages;

      var columns;
      if (scopedSlot) {
        var proxyHash = new Proxy({}, { get: function () { return ''; } });
        columns = scopedSlot(( obj = {}, obj[recordVariable] = proxyHash, obj ));
      } else {
        columns = defaultSlot;
      }
      columns = columns.filter(function (column) { return column.tag === 'td'; });

      var childScopedSlots = {};
      if (paginated && totalPages > 1 && !context.slots().footer) {
        childScopedSlots.footer = function () {
          return h('tfoot', [
            h('tr', [
              h('td', { attrs: { colspan: columns.length } }, [
                h(PaginationLinks, {
                  props: pick$1(context.props, Object.keys(PaginationLinks.props)),
                  on: {
                    'update:currentPage': listeners['update:currentPage']
                  }
                })
              ])
            ])
          ])
        };
      }

      return h(vueSlotHooks.RenderWithSlotHooks, {
        props: {
          inheritSlots: true,
          slotName: 'footer',
          tag: null,
          passSlotsToTag: false,
          slotScopeData: {
            columns: columns
          }
        },
        scopedSlots: childScopedSlots
      })
    }
  };

  var TableForPaginator = {
    props: {
      currentPage: {
        type: Number,
        default: 1
      },
      perPage: {
        type: Number,
        default: 10
      },
      records: {
        type: Array,
        required: true
      }
    },

    computed: {
      totalPages: function totalPages() {
        return Math.ceil(this.records.length / this.perPage)
      },
      currentPageRecords: function currentPageRecords() {
        var recordOffset = (this.currentPage - 1) * this.perPage;
        return this.records.slice(recordOffset, recordOffset + this.perPage)
      }
    },

    watch: {
      totalPages: {
        handler: function handler() {
          this.$emit('update:totalPages', this.totalPages);
        },
        immediate: true
      },
      currentPageRecords: {
        handler: function handler() {
          this.$emit('update:currentPageRecords', this.currentPageRecords);
        },
        immediate: true
      }
    },

    render: function render() {
      return null
    }
  };

  var TableFor = {
    props: Object.assign({}, {recordVariable: {
        type: String,
        default: 'record'
      }},
      pick(TableHeader.props, ['header']),
      pick(TableBody.props, ['records', 'dataRow', 'formatter', 'body']),
      pick(TableFooter, ['paginationLinksInFooter']),
      TableForPaginator.props,
      {paginated: {
        type: Boolean,
        default: false
      },
      paginateInternally: {
        type: Boolean,
        default: false
      },
      totalPages: {
        type: Number,
        default: 0
      }}),
    data: function data() {
      return {
        currentPageRecords: [],
        pages: 0,
        page: 1
      }
    },
    watch: {
      currentPage: {
        handler: function handler() {
          this.page = this.currentPage;
        },
        immediate: true
      },
      totalPages: {
        handler: function handler() {
          this.pages = this.totalPages;
        },
        immediate: true
      },
      records: {
        handler: function handler() {
          this.currentPageRecords = this.records;
        },
        immediate: true
      },
      paginated: function paginated() {
        this.currentPageRecords = this.records;
      }
    },
    methods: {
      handleUpdateTotalPages: function handleUpdateTotalPages(totalPages) {
        this.pages = totalPages;
      },
      handleUpdateCurrentPageRecords: function handleUpdateCurrentPageRecords(records) {
        this.currentPageRecords = records;
        this.$emit('update:currentPageRecords', records);
      },
      handleUpdateCurrentPage: function handleUpdateCurrentPage(currentPage) {
        this.page = currentPage;
        this.$emit('update:currentPage', currentPage);
      }
    },
    render: function render(h) {
      var scopedSlots = this.$scopedSlots || {};
      var paginator;
      if (this.paginated) {
        if (this.paginateInternally) {
          paginator = h(TableForPaginator, {
            props: Object.assign({}, pick(this.$props, Object.keys(TableForPaginator.props)),
              {currentPage: this.page}),
            on: {
              'update:totalPages': this.handleUpdateTotalPages,
              'update:currentPageRecords': this.handleUpdateCurrentPageRecords
            }
          });
        }
      }

      return h('table', {}, [
        paginator,
        h(
          TableHeader,
          {
            props: pick(this.$props, Object.keys(TableHeader.props)),
            scopedSlots: scopedSlots
          },
          [h(vueInheritSlots.InheritSlots, { props: { inheritDefaultSlot: true } })]
        ),
        h(
          TableBody,
          {
            props: Object.assign({}, pick(this.$props, Object.keys(TableBody.props)),
              {records: this.currentPageRecords}),
            scopedSlots: scopedSlots
          },
          [h(vueInheritSlots.InheritSlots, { props: { inheritDefaultSlot: true } })]
        ),
        h(
          TableFooter,
          {
            props: Object.assign({}, pick(this.$props, Object.keys(TableFooter.props)),
              {currentPage: this.page,
              totalPages: this.pages}),
            on: {
              'update:currentPage': this.handleUpdateCurrentPage
            },
            scopedSlots: scopedSlots
          },
          [h(vueInheritSlots.InheritSlots, { props: { inheritDefaultSlot: true } })]
        )
      ])
    }
  };

  var VueTableForPlugin = {
    install: function install(Vue, options) {
      if ( options === void 0 ) options = {};

      // TODO: allow options to be specified for global settings
      Vue.component(options.alias || 'TableFor', TableFor);
    }
  };

  // Automatic installation if Vue has been added to the global scope.
  if (typeof window !== 'undefined' && window.Vue) {
    window.Vue.use(VueTableForPlugin);
  }

  exports.default = VueTableForPlugin;
  exports.TableFor = TableFor;
  exports.PaginationLinks = PaginationLinks;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
