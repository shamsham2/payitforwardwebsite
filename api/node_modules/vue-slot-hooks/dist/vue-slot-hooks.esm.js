import { InheritSlots } from 'vue-inherit-slots';

// Created / adapted custom implementations of methods available from lodash and deepmerge as they were adding nearly
//  180kb to the generated lib files

// Solution found here: https://stackoverflow.com/a/37616104/400699
function filterObject(object, predicate) {
  if (typeof object === 'undefined') {
    return {}
  } else {
    return Object.keys(object)
      .filter(function (key) { return predicate(key, object[key]); })
      .reduce(function (result, key) { return ((result[key] = object[key]), result); }, {})
  }
}

function omit(object, keys) {
  return filterObject(object, function (key) { return keys.indexOf(key) === -1; })
}

function pick(object, keys) {
  return filterObject(object, function (key) { return keys.indexOf(key) !== -1; })
}

// Adapted from https://youmightnotneed.com/lodash/
function flatten(array) {
  return array.reduce(function (a, b) { return a.concat(b); }, [])
}

// Adapted from https://youmightnotneed.com/lodash/
function compact(array) {
  return array.filter(function (x) { return !!x; })
}

var HelperUtils = {};

function renderableSlotScope(content, data) {
  if ( data === void 0 ) data = {};

  return Object.assign({}, data, {functional: true, render: function () { return content; }})
}

var RenderUtils = {};

var RenderSlot = {
  props: {
    name: {
      required: true,
      type: String
    },
    slots: {
      type: Object,
      required: true
    },
    scopedSlots: {
      type: Object,
      required: true
    },
    skip: {
      type: Boolean,
      default: false
    },
    firstSlotOnly: {
      type: Boolean,
      default: false
    },
    fallbackTag: {},
    fallbackTagData: {
      type: Object
    },
    slotReplacesChildren: {
      type: Boolean,
      default: false
    },
    slotScopeData: {
      type: Object,
      default: function default$1() {
        return {}
      }
    }
  },
  functional: true,
  render: function render(h, context) {
    var ref = context.props;
    var name = ref.name;
    var slots = ref.slots;
    var scopedSlots = ref.scopedSlots;
    var skip = ref.skip;
    var firstSlotOnly = ref.firstSlotOnly;
    var fallbackTag = ref.fallbackTag;
    var fallbackTagData = ref.fallbackTagData;
    var slotReplacesChildren = ref.slotReplacesChildren;
    var slotScopeData = ref.slotScopeData;
    var slot, scopedSlot;

    slot = slots[name];
    scopedSlot = scopedSlots[name];

    var children = slotReplacesChildren ? [] : context.children;

    if (skip || (!slot && !scopedSlot)) {
      if (fallbackTag) {
        return [
          h(
            fallbackTag,
            fallbackTagData,
            flatten(Object.values(context.slots()))
          )
        ]
      } else {
        return context.children ? compact(context.children) : []
      }
    } else if (scopedSlot) {
      return compact([scopedSlot(renderableSlotScope(children, slotScopeData))])
    } else {
      var slotsToRender = firstSlotOnly ? slot.slice(0, 1) : slot;
      return compact(
        slotsToRender.map(function (slot) {
          var data = omit(slot.data || {}, ['slot']);

          if (slot.tag && !slot.componentOptions) {
            return h(slot.tag, data, (children || []).concat( (slot.children || [])
            ))
          } else {
            return slot
          }
        })
      )
    }
  }
};

var RenderSlotHooks = {
  props: {
    slotName: {
      type: String,
      default: null
    },
    innerSlotHooksOnly: {
      type: Boolean,
      default: false
    },
    tag: {
      required: true
    },
    tagData: {
      type: Object,
      default: null
    },
    slotScopeData: {
      type: Object,
      default: function default$1() {
        return {}
      }
    },
    passSlotsToTag: {
      type: Boolean,
      default: true
    },
    slotHookNameResolver: {
      type: Function,
      required: true
    },
    replaceable: {
      type: Boolean,
      default: true
    }
  },
  components: {
    RenderSlot: RenderSlot
  },
  functional: true,
  render: function render(createElement, context) {
    var slots = context.slots();
    var scopedSlots = context.data.scopedSlots;
    var ref = context.props;
    var slotName = ref.slotName;
    var tag = ref.tag;
    var innerSlotHooksOnly = ref.innerSlotHooksOnly;
    var slotHookNameResolver = ref.slotHookNameResolver;
    var passSlotsToTag = ref.passSlotsToTag;
    var replaceable = ref.replaceable;
    var slotScopeData = ref.slotScopeData;

    var slotProps = Object.assign({}, context.props, {slots: slots, scopedSlots: scopedSlots, slotScopeData: slotScopeData});

    var slotHookNames = [
      'before_all',
      'around_all',
      'after_all',
      'before',
      'around',
      'after',
      'around_content',
      'prepend',
      'default',
      'append',
      'tag'
    ].reduce(function (hash, hookName) {
      hash[hookName] = slotHookNameResolver(slotName, hookName);
      return hash
    }, {});

    var slotNamesUsed = flatten(Object.values(slotHookNames));

    var slotChildren = passSlotsToTag
      ? flatten(Object.values(omit(slots, slotNamesUsed)))
      : [];

    var slotDataFor = function (hookName, additionalProps) {
      if ( additionalProps === void 0 ) additionalProps = {};

      return {
        props: Object.assign({}, slotProps,
          additionalProps,
          {name: slotHookNames[hookName]})
      }
    };

    var tagData = Object.assign({}, (context.props.tagData || omit(context.data, ['props'])),
      {scopedSlots: omit(scopedSlots, slotNamesUsed)});

    if (replaceable) {
      tagData = slotDataFor('tag', {
        firstSlotOnly: true,
        fallbackTagData: tagData,
        fallbackTag: tag,
        slotReplacesChildren: true
      });
      tag = RenderSlot;
    }

    var innerContent = createElement(tag, tagData, slotChildren.concat( [createElement(
        RenderSlot,
        slotDataFor('around_content', {
          firstSlotOnly: true
        }),
        [
          createElement(RenderSlot, slotDataFor('prepend')),
          createElement(RenderSlot, slotDataFor('default')),
          createElement(RenderSlot, slotDataFor('append'))
        ]
      )]
    ));

    if (innerSlotHooksOnly) {
      return innerContent
    } else {
      return [
        createElement(RenderSlot, slotDataFor('before_all')),
        createElement(
          RenderSlot,
          slotDataFor('around_all', {
            firstSlotOnly: true
          }),
          [
            createElement(RenderSlot, slotDataFor('before', {})),
            createElement(
              RenderSlot,
              slotDataFor('around', {
                firstSlotOnly: true
              }),
              [innerContent]
            ),
            createElement(RenderSlot, slotDataFor('after'))
          ]
        ),
        createElement(RenderSlot, slotDataFor('after_all'))
      ]
    }
  }
};

// TODO: ability to provide an alias to fields as a kind of backup for where to find definitions
//  For local development:
// import InheritSlots from '../../../vue-inherit-slots/src/components/InheritSlots'

var RenderWithSlotHooks = {
  props: Object.assign({}, omit(RenderSlotHooks.props, ['tag', 'slotHookNameResolver']),
    InheritSlots.props,
    {inheritSlots: {
      type: Boolean,
      default: false
    },
    tag: {
      default: null
    },
    slotHookRenderer: {
      type: Object,
      default: function default$1() {
        return RenderSlotHooks
      }
    },
    slotHookNameResolver: {
      type: Function,
      default: function default$2(slotName, hookName) {
        if (hookName === 'tag') {
          return slotName || 'tag'
        } else if (hookName === 'default') {
          return 'default'
        } else if (hookName === 'around_content') {
          return slotName ? ("around_" + slotName + "_content") : hookName
        } else {
          return slotName ? (hookName + "_" + slotName) : hookName
        }
      }
    }}),
  functional: true,
  render: function render(createElement, context) {
    var ref = context.props;
    var inheritSlots = ref.inheritSlots;
    var slotHookRenderer = ref.slotHookRenderer;
    var tag = ref.tag;
    var scopedSlots = context.data.scopedSlots || {};
    tag = tag || context.data.tag;

    var inheritedSlots = [];
    if (inheritSlots) {
      inheritedSlots = [
        createElement(InheritSlots, {
          scopedSlots: scopedSlots,
          props: pick(context.props, Object.keys(InheritSlots.props))
        })
      ];
    }
    return createElement(
      slotHookRenderer,
      Object.assign({}, context.data,
        {scopedSlots: scopedSlots,
        props: Object.assign({}, pick(context.props, Object.keys(RenderSlotHooks.props)),
          {tag: tag})}),
      inheritedSlots.concat( (context.children || []))
    )
  }
};

var VueSlotHooksPlugin = {
  install: function install(Vue, options) {
    if ( options === void 0 ) options = {};

    Vue.component(options.alias || 'RenderWithSlotHooks', RenderWithSlotHooks);
  }
};

// Automatic installation if Vue has been added to the global scope.
if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(VueSlotHooksPlugin);
}

export default VueSlotHooksPlugin;
export { RenderWithSlotHooks, HelperUtils, RenderUtils };
